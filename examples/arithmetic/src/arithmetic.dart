// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

library api;

import "dart:convert";
import "dart:ffi";
import "dart:io" show Platform, File, Directory;
import "dart:typed_data";
import "package:ffi/ffi.dart";

// // Depending on the consumer's build setup, the low-level FFI code
// // might be in a separate module, or it might be compiled inline into
// // this module. This is a bit of light hackery to work with both.
// #if canImport(arithmeticFFI)
// import arithmeticFFI
// #endif

class RustBuffer extends Struct {
  @Int32()
  external int capacity;

  @Int32()
  external int len;

  external Pointer data;

  static RustBuffer fromBytes(Api api, ForeignBytes bytes) {
    final _fromBytesPtr = api
        ._lookup<NativeFunction<Void Function(ForeignBytes, RustCallStatus)>>(
            "ffi_arithmetic_4fd4_rustbuffer_from_bytes");
    final fromBytes =
        _fromBytesPtr.asFunction<void Function(ForeignBytes, RustCallStatus)>();
    return rustCall(api, (res) => fromBytes(bytes, res));
  }
}

class ForeignBytes extends Struct {
  @Int32()
  external int len;

  external Pointer data;

  /// generated by @struct annotation
  external static int sizeOf();

  static ForeignBytes allocate({int count = 1}) =>
      calloc<ForeignBytes>(count: count * sizeOf()).cast();
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.

class UniffiInternalError extends Exception {
  static const int bufferOverflow = 0;
  static const int incompleteData = 1;
  static const int unexpectedOptionalTag = 2;
  static const int unexpectedEnumCase = 3;
  static const int unexpectedNullPointer = 4;
  static const int unexpectedRustCallStatusCode = 5;
  static const int unexpectedRustCallError = 6;
  static const int unexpectedStaleHandle = 7;
  static const int rustPanic = 8;

  final int errorCode;
  final String? panicMessage;

  UniffiInternalError(this.errorCode, this.panicMessage);

  static UniffiInternalError panicked(String message) {
    return UniffiInternalError(rustPanic, message);
  }

  @override
  String toString() {
    switch (errorCode) {
      case bufferOverflow:
        return "UniFfi::BufferOverflow";
      case incompleteData:
        return "UniFfi::IncompleteData";
      case unexpectedOptionalTag:
        return "UniFfi::UnexpectedOptionalTag";
      case unexpectedEnumCase:
        return "UniFfi::UnexpectedEnumCase";
      case unexpectedNullPointer:
        return "UniFfi::UnexpectedNullPointer";
      case unexpectedRustCallStatusCode:
        return "UniFfi::UnexpectedRustCallStatusCode";
      case unexpectedRustCallError:
        return "UniFfi::UnexpectedRustCallError";
      case unexpectedStaleHandle:
        return "UniFfi::UnexpectedStaleHandle";
      case rustPanic:
        return "UniFfi::rustPanic: $panicMessage";
      default:
        return "UniFfi::UnknownError: $errorCode";
    }
  }
}

const int CALL_SUCCESS = 0;
const int CALL_ERROR = 1;
const int CALL_PANIC = 2;

class RustCallStatus extends Struct {
  @Int8()
  external int code;
  external RustBuffer errorBuf;

  /// generated by @struct annotation
  external static int sizeOf();

  static RustCallStatus allocate({int count = 1}) =>
      calloc<RustCallStatus>(count: count * sizeOf()).cast();
}

T noop<T>(T t) {
  return t;
}

T rustCall<T>(Api api, Function(RustCallStatus) callback) {
  var callStatus = RustCallStatus.allocate();
  final returnValue = callback(callStatus);

  switch (callStatus.code) {
    case CALL_SUCCESS:
      calloc.free(callStatus);
      return returnValue;
    case CALL_ERROR:
      throw callStatus.errorBuf;
    case CALL_PANIC:
      if (callStatus.errorBuf.len > 0) {
        final message = FfiConverterString.lift(api, callStatus.errorBuf);
        calloc.free(callStatus);
        throw UniffiInternalError.panicked(message);
      } else {
        calloc.free(callStatus);
        throw UniffiInternalError.panicked("Rust panic");
      }
    default:
      throw UniffiInternalError(callStatus.code, null);
  }
}

// Public interface members begin here.

typedef Uint64Ffi = Uint64;
typedef Uint64Lowered = Uint64;
typedef Uint64Lifted = int;
typedef Uint64DartFfi = int;

class FfiConverterUint64 {
  static Uint64Lowered lift(Uint64Lowered value) {
    return value;
  }

  static Uint64Lifted lower(Uint64Lifted value) {
    return value;
  }
}

typedef BoolFfi = Int8;
typedef BoolDartFfi = int;
typedef BoolLowered = Int8;
typedef BoolLifted = bool;

class FfiConverterbool {
  //extends FfiConverter {

  static BoolLifted lift(Api _api, BoolDartFfi value) {
    return value != 0;
  }

  static int lower(BoolLifted value) {
    return value ? 1 : 0;
  }
}

typedef StringLowered = RustBuffer;
typedef StringLifted = String;

typedef StringFfi = RustBuffer;

class FfiConverterString {
  static StringLifted? lift(StringLowered value) {
    return utf8.decode(value.data.asTypedList(value.len));
  }

  static RustBuffer lower(Api api, String value) {
    final units = utf8.encode(value);
    final Pointer<Uint8> result = calloc<Uint8>(units.length);
    final Uint8List nativeString = result.asTypedList(units.length);
    nativeString.setAll(0, units);
    final ForeignBytes bytes = calloc<ForeignBytes>();
    bytes.data = result;
    bytes.len = units.length;
    return RustBuffer.fromBytes(api, bytes);
  }
}

/// Main entry point to library.
class Api {
  /// Holds the symbol lookup function.
  final Pointer<T> Function<T extends NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(
      Pointer<T> Function<T extends NativeType>(String symbolName) lookup)
      : _lookup = lookup;

  /// The library is loaded from the executable.
  factory Api.loadStatic() {
    return Api(DynamicLibrary.executable());
  }

  /// The library is dynamically loaded.
  factory Api.loadDynamic(String name) {
    return Api(DynamicLibrary.open(name));
  }

  /// The library is loaded based on platform conventions.
  factory Api.load() {
    String? name;
    if (Platform.isLinux) name = "libarithmetic.so";
    if (Platform.isAndroid) name = "libarithmetic.so";
    if (Platform.isMacOS) name = "libarithmetic.dylib";
    if (Platform.isIOS) name = "";
    if (Platform.isWindows) name = "arithmetic.dll";
    if (name == null) {
      throw UnsupportedError("\"This platform is not supported.\"");
    }
    if (name == "") {
      return Api.loadStatic();
    } else {
      return Api.loadDynamic(name);
    }
  }

  late final _addPtr = _lookup<
      NativeFunction<
          Uint64Ffi Function(Uint64Lowered, Uint64Lowered,
              RustCallStatus)>>("arithmetic_4fd4_add");

  late final _add = _addPtr.asFunction<
      Uint64DartFfi Function(Uint64Lifted, Uint64Lifted, RustCallStatus)>();

  Uint64Lifted add(Uint64Lifted a, Uint64Lifted b) {
    return rustCall(this, (status) => _add(a, b, status));
  }

  late final _subPtr = _lookup<
      NativeFunction<
          Uint64Ffi Function(Uint64Lowered, Uint64Lowered,
              RustCallStatus)>>("arithmetic_4fd4_sub");

  late final _sub = _subPtr.asFunction<
      Uint64DartFfi Function(Uint64Lifted, Uint64Lifted, RustCallStatus)>();

  Uint64Lifted sub(Uint64Lifted a, Uint64Lifted b) {
    return rustCall(this, (status) => _sub(a, b, status));
  }

  late final _divPtr = _lookup<
      NativeFunction<
          Uint64Ffi Function(Uint64Lowered, Uint64Lowered,
              RustCallStatus)>>("arithmetic_4fd4_div");

  late final _div = _divPtr.asFunction<
      Uint64DartFfi Function(Uint64Lifted, Uint64Lifted, RustCallStatus)>();

  Uint64Lifted div(Uint64Lifted dividend, Uint64Lifted divisor) {
    return rustCall(this, (status) => _div(dividend, divisor, status));
  }

  late final _equalPtr = _lookup<
      NativeFunction<
          BoolFfi Function(Uint64Lowered, Uint64Lowered,
              RustCallStatus)>>("arithmetic_4fd4_equal");

  late final _equal = _equalPtr.asFunction<
      BoolDartFfi Function(Uint64Lifted, Uint64Lifted, RustCallStatus)>();

  BoolLifted equal(Uint64Lifted a, Uint64Lifted b) {
    return rustCall(this, (status) => _equal(a, b, status));
  }
}
